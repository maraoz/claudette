[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "claudette",
    "section": "",
    "text": "NB: If you are reading this in GitHub’s readme, we recommend you instead read the much more nicely formatted documentation format of this tutorial.\n\nClaudette is a wrapper for Anthropic’s Python SDK.\nThe SDK works well, but it is quite low level – it leaves the developer to do a lot of stuff manually. That’s a lot of extra work and boilerplate! Claudette automates pretty much everything that can be automated, whilst providing full control. Amongst the features provided:\n\nA Chat class that creates stateful dialogs\nSupport for prefill, which tells Claude what to use as the first few words of its response\nConvenient image support\nSimple and convenient support for Claude’s new Tool Use API.\n\nYou’ll need to set the ANTHROPIC_API_KEY environment variable to the key provided to you by Anthropic in order to use this library.\nNote that this library is the first ever “literate nbdev” project. That means that the actual source code for the library is a rendered Jupyter Notebook which includes callout notes and tips, HTML tables and images, detailed explanations, and teaches how and why the code is written the way it is. Even if you’ve never used the Anthropic Python SDK or Claude API before, you should be able to read the source code. Click Claudette’s Source to read it, or clone the git repo and execute the notebook yourself to see every step of the creation process in action. The tutorial below includes links to API details which will take you to relevant parts of the source. The reason this project is a new kind of literal program is because we take seriously Knuth’s call to action, that we have a “moral commitment” to never write an “illiterate program” – and so we have a commitment to making literate programming and easy and pleasant experience. (For more on this, see this talk from Hamel Husain.)\n\n“Let us change our traditional attitude to the construction of programs: Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.” Donald E. Knuth, Literate Programming (1984)",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "claudette",
    "section": "Install",
    "text": "Install\npip install claudette",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "claudette",
    "section": "Getting started",
    "text": "Getting started\nAnthropic’s Python SDK will automatically be installed with Claudette, if you don’t already have it.\n\nimport os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\n\nTo print every HTTP request and response in full, uncomment the above line.\n\nfrom claudette import *\n\nClaudette only exports the symbols that are needed to use the library, so you can use import * to import them. Alternatively, just use:\nimport claudette\n…and then add the prefix claudette. to any usages of the module.\nClaudette provides models, which is a list of models currently available from the SDK.\n\nmodels\n\n('claude-3-opus-20240229',\n 'claude-3-5-sonnet-20240620',\n 'claude-3-haiku-20240307')\n\n\nFor these examples, we’ll use Sonnet 3.5, since it’s awesome!\n\nmodel = models[1]",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#chat",
    "href": "index.html#chat",
    "title": "claudette",
    "section": "Chat",
    "text": "Chat\nThe main interface to Claudette is the Chat class, which provides a stateful interface to Claude:\n\nchat = Chat(model, sp=\"\"\"You are a helpful and concise assistant.\"\"\")\nchat(\"I'm Jeremy\")\n\nHello Jeremy, it’s nice to meet you. How can I assist you today?\n\n\nid: msg_01KLrPzN79dXmDhTH2Nv6tjn\ncontent: [{‘text’: “Hello Jeremy, it’s nice to meet you. How can I assist you today?”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 19, ‘output_tokens’: 20}\n\n\n\n\n\nr = chat(\"What's my name?\")\nr\n\nYour name is Jeremy, as you just told me.\n\n\nid: msg_01VsZr9D5ptbWrggdX28y1J5\ncontent: [{‘text’: ‘Your name is Jeremy, as you just told me.’, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 47, ‘output_tokens’: 14}\n\n\n\n\nAs you see above, displaying the results of a call in a notebook shows just the message contents, with the other details hidden behind a collapsible section. Alternatively you can print the details:\n\nprint(r)\n\nMessage(id='msg_01VsZr9D5ptbWrggdX28y1J5', content=[TextBlock(text='Your name is Jeremy, as you just told me.', type='text')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=In: 47; Out: 14; Total: 61)\n\n\nClaude supports adding an extra assistant message at the end, which contains the prefill – i.e. the text we want Claude to assume the response starts with. Let’s try it out:\n\nchat(\"Concisely, what is the meaning of life?\",\n     prefill='According to Douglas Adams,')\n\nAccording to Douglas Adams, “42.” More seriously, it’s often considered to be finding personal fulfillment, happiness, and purpose.\n\n\nid: msg_01RMBD95RyQjbsNckGYmRMLu\ncontent: [{‘text’: ‘According to Douglas Adams, “42.” More seriously, it's often considered to be finding personal fulfillment, happiness, and purpose.’, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 81, ‘output_tokens’: 27}\n\n\n\n\nYou can add stream=True to stream the results as soon as they arrive (although you will only see the gradual generation if you execute the notebook yourself, of course!)\n\nfor o in chat(\"Concisely, what book was that in?\", prefill='It was in', stream=True):\n    print(o, end='')\n\nIt was in \"The Hitchhiker's Guide to the Galaxy\" by Douglas Adams.",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#tool-use",
    "href": "index.html#tool-use",
    "title": "claudette",
    "section": "Tool use",
    "text": "Tool use\nTool use lets Claude use external tools.\nWe use docments to make defining Python functions as ergonomic as possible. Each parameter (and the return value) should have a type, and a docments comment with the description of what it is. As an example we’ll write a simple function that adds numbers together, and will tell us when it’s being called:\n\ndef sums(\n    a:int,  # First thing to sum\n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\nSometimes Claude will say something like “according to the sums tool the answer is” – generally we’d rather it just tells the user the answer, so we can use a system prompt to help with this:\n\nsp = \"Never mention what tools you use.\"\n\nWe’ll get Claude to add up some long numbers:\n\na,b = 604542,6458932\npr = f\"What is {a}+{b}?\"\npr\n\n'What is 604542+6458932?'\n\n\nTo use tools, pass a list of them to Chat, and to force it to always answer using a tool, set tool_choice to that function name:\n\nchat = Chat(model, sp=sp, tools=[sums], tool_choice='sums')\n\nNow when we call that with our prompt, Claude doesn’t return the answer, but instead returns a tool_use message, which means we have to call the named tool with the provided parameters:\n\nr = chat(pr)\nr\n\nFinding the sum of 604542 and 6458932\n\n\nToolUseBlock(id=‘toolu_018a7fT3Mnoa2XqtAMXqawXU’, input={‘a’: 604542, ‘b’: 6458932}, name=‘sums’, type=‘tool_use’)\n\n\nid: msg_011r1ZTjJSLFCJKceMoFSPky\ncontent: [{‘id’: ‘toolu_018a7fT3Mnoa2XqtAMXqawXU’, ‘input’: {‘a’: 604542, ‘b’: 6458932}, ‘name’: ‘sums’, ‘type’: ‘tool_use’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 414, ‘output_tokens’: 53}\n\n\n\n\nClaudette handles all that for us – we just call it again, and it all happens automatically:\n\nchat()\n\nFinding the sum of 7063474 and 1\n\n\nToolUseBlock(id=‘toolu_01Pc9N6fQSUNnuqrUKR2DkmL’, input={‘a’: 7063474}, name=‘sums’, type=‘tool_use’)\n\n\nid: msg_01Ct8URrPt5hf5mjUSndwigS\ncontent: [{‘id’: ‘toolu_01Pc9N6fQSUNnuqrUKR2DkmL’, ‘input’: {‘a’: 7063474}, ‘name’: ‘sums’, ‘type’: ‘tool_use’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 502, ‘output_tokens’: 35}\n\n\n\n\nYou can see how many tokens have been used at any time by checking the use property. Note that (as of May 2024) tool use in Claude uses a lot of tokens, since it automatically adds a large system prompt.\n\nchat.use\n\nIn: 916; Out: 88; Total: 1004\n\n\nWe can do everything needed to use tools in a single step, by using Chat.toolloop. This can even call multiple tools as needed solve a problem. For example, let’s define a tool to handle multiplication:\n\ndef mults(\n    a:int,  # First thing to multiply\n    b:int=1 # Second thing to multiply\n) -&gt; int: # The product of the inputs\n    \"Multiplies a * b.\"\n    print(f\"Finding the product of {a} and {b}\")\n    return a * b\n\nNow with a single call we can calculate (a+b)*2 – by passing show_trace we can see each response from Claude in the process:\n\nchat = Chat(model, sp=sp, tools=[sums,mults])\npr = f'Calculate ({a}+{b})*2'\npr\n\n'Calculate (604542+6458932)*2'\n\n\n\nchat.toolloop(pr, trace_func=print)\n\nFinding the sum of 604542 and 6458932\nMessage(id='msg_016tRhA75RqXTkCMR9WoZvyE', content=[TextBlock(text='Certainly! To calculate (604542+6458932)*2, we\\'ll need to use the available tools to perform the addition and multiplication operations. Let\\'s break it down step by step:\\n\\n1. First, we\\'ll add 604542 and 6458932 using the \"sums\" function.\\n2. Then, we\\'ll multiply the result by 2 using the \"mults\" function.\\n\\nLet\\'s start with the addition:', type='text'), ToolUseBlock(id='toolu_017aomxeCUA6DxM9U6UQjMu2', input={'a': 604542, 'b': 6458932}, name='sums', type='tool_use')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='tool_use', stop_sequence=None, type='message', usage=In: 538; Out: 168; Total: 706)\nFinding the product of 7063474 and 2\nMessage(id='msg_016w97cNedVktfhHUoL2Ey7a', content=[TextBlock(text=\"Great! The sum of 604542 and 6458932 is 7063474.\\n\\nNow, let's multiply this result by 2:\", type='text'), ToolUseBlock(id='toolu_0115UMmS2GMeej1CafKLKvBB', input={'a': 7063474, 'b': 2}, name='mults', type='tool_use')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='tool_use', stop_sequence=None, type='message', usage=In: 721; Out: 106; Total: 827)\nMessage(id='msg_0139BkRu9b9yKPp8N8NHBMpj', content=[TextBlock(text='Now we have our final result. \\n\\nThe calculation (604542+6458932)*2 equals 14126948.\\n\\nTo break it down:\\n1. 604542 + 6458932 = 7063474\\n2. 7063474 * 2 = 14126948\\n\\nSo, the final answer to (604542+6458932)*2 is 14126948.', type='text')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=In: 841; Out: 95; Total: 936)\n\n\nNow we have our final result.\nThe calculation (604542+6458932)*2 equals 14126948.\nTo break it down: 1. 604542 + 6458932 = 7063474 2. 7063474 * 2 = 14126948\nSo, the final answer to (604542+6458932)*2 is 14126948.\n\n\nid: msg_0139BkRu9b9yKPp8N8NHBMpj\ncontent: [{‘text’: ’Now we have our final result. calculation (604542+6458932)2 equals 14126948.break it down:. 604542 + 6458932 = 7063474. 7063474  2 = 14126948, the final answer to (604542+6458932)*2 is 14126948.’, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 841, ‘output_tokens’: 95}",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#images",
    "href": "index.html#images",
    "title": "claudette",
    "section": "Images",
    "text": "Images\nClaude can handle image data as well. As everyone knows, when testing image APIs you have to use a cute puppy.\n\nfn = Path('samples/puppy.jpg')\ndisplay.Image(filename=fn, width=200)\n\n\n\n\n\n\n\n\nWe create a Chat object as before:\n\nchat = Chat(model)\n\nClaudette expects images as a list of bytes, so we read in the file:\n\nimg = fn.read_bytes()\n\nPrompts to Claudette can be lists, containing text, images, or both, eg:\n\nchat([img, \"In brief, what color flowers are in this image?\"])\n\nThe flowers in this image are purple. They appear to be small, daisy-like flowers, possibly asters or some type of purple wildflower, blooming in the background behind the adorable puppy in the foreground.\n\n\nid: msg_01EsC5ZMpo5chJRzcjkceLu9\ncontent: [{‘text’: ‘The flowers in this image are purple. They appear to be small, daisy-like flowers, possibly asters or some type of purple wildflower, blooming in the background behind the adorable puppy in the foreground.’, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 110, ‘output_tokens’: 51}\n\n\n\n\nThe image is included as input tokens.\n\nchat.use\n\nIn: 110; Out: 51; Total: 161\n\n\nAlternatively, Claudette supports creating a multi-stage chat with separate image and text prompts. For instance, you can pass just the image as the initial prompt (in which case Claude will make some general comments about what it sees), and then follow up with questions in additional prompts:\n\nchat = Chat(model)\nchat(img)\n\nThis image shows an adorable puppy lying in the grass. The puppy appears to be a Cavalier King Charles Spaniel or a similar breed, with distinctive white and reddish-brown fur coloring. Its face is predominantly white with large, expressive dark eyes and a small black nose.\nThe puppy is resting on a grassy surface, giving the impression of being outdoors. In the background, you can see purple flowers, which look like asters or michaelmas daisies, adding a lovely splash of color to the scene. There’s also what appears to be a wooden structure or fence behind the flowers, suggesting a garden setting.\nThe composition of the image creates a charming, pastoral scene that highlights the puppy’s cuteness against the natural backdrop. The contrast between the soft fur of the puppy and the delicate purple flowers makes for a visually appealing and heartwarming picture.\n\n\nid: msg_013TMWFVwfmYh2qzUtUqen68\ncontent: [{‘text’: “This image shows an adorable puppy lying in the grass. The puppy appears to be a Cavalier King Charles Spaniel or a similar breed, with distinctive white and reddish-brown fur coloring. Its face is predominantly white with large, expressive dark eyes and a small black nose.puppy is resting on a grassy surface, giving the impression of being outdoors. In the background, you can see purple flowers, which look like asters or michaelmas daisies, adding a lovely splash of color to the scene. There’s also what appears to be a wooden structure or fence behind the flowers, suggesting a garden setting.composition of the image creates a charming, pastoral scene that highlights the puppy’s cuteness against the natural backdrop. The contrast between the soft fur of the puppy and the delicate purple flowers makes for a visually appealing and heartwarming picture.”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 98, ‘output_tokens’: 197}\n\n\n\n\n\nchat('What direction is the puppy facing?')\n\nThe puppy in the image is facing towards the camera, looking directly at the viewer. Its head is slightly tilted, giving it an endearing and curious expression. The puppy’s body is angled slightly to its left (our right), with its front paws visible and resting on the grass. This positioning allows us to see the full face of the puppy, showcasing its adorable features and the distinctive color pattern of its fur.\n\n\nid: msg_015W9aQZt9JsjExJKcN72cDo\ncontent: [{‘text’: “The puppy in the image is facing towards the camera, looking directly at the viewer. Its head is slightly tilted, giving it an endearing and curious expression. The puppy’s body is angled slightly to its left (our right), with its front paws visible and resting on the grass. This positioning allows us to see the full face of the puppy, showcasing its adorable features and the distinctive color pattern of its fur.”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 306, ‘output_tokens’: 95}\n\n\n\n\n\nchat('What color is it?')\n\nThe puppy in the image has a combination of two main colors:\n\nWhite: The majority of its face, including the muzzle area and a portion of its body that’s visible, is white.\nReddish-brown (often called “chestnut” or “ruby” in this breed): This color appears on the ears and extends to patches on the body, though the full extent isn’t visible in this image.\n\nThis color combination is typical for Cavalier King Charles Spaniels, particularly the Blenheim variety. The contrast between the white and the reddish-brown fur creates a striking and adorable appearance, highlighting the puppy’s facial features and giving it a distinctive look.\n\n\nid: msg_0146KQcPjSoXFGLjqjpzwU3Q\ncontent: [{‘text’: ‘The puppy in the image has a combination of two main colors:. White: The majority of its face, including the muzzle area and a portion of its body that's visible, is white.. Reddish-brown (often called “chestnut” or “ruby” in this breed): This color appears on the ears and extends to patches on the body, though the full extent isn't visible in this image.color combination is typical for Cavalier King Charles Spaniels, particularly the Blenheim variety. The contrast between the white and the reddish-brown fur creates a striking and adorable appearance, highlighting the puppy's facial features and giving it a distinctive look.’, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 409, ‘output_tokens’: 157}\n\n\n\n\nNote that the image is passed in again for every input in the dialog, so that number of input tokens increases quickly with this kind of chat.\n\nchat.use\n\nIn: 813; Out: 449; Total: 1262",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "index.html#other-model-providers",
    "href": "index.html#other-model-providers",
    "title": "claudette",
    "section": "Other model providers",
    "text": "Other model providers\nYou can also use 3rd party providers of Anthropic models, as shown here.\n\nAmazon Bedrock\nThese are the models available through Bedrock:\n\nmodels_aws\n\n('anthropic.claude-3-haiku-20240307-v1:0',\n 'anthropic.claude-3-sonnet-20240229-v1:0',\n 'anthropic.claude-3-opus-20240229-v1:0',\n 'anthropic.claude-3-5-sonnet-20240620-v1:0')\n\n\nTo use them, call AnthropicBedrock with your access details, and pass that to Client:\n\nfrom anthropic import AnthropicBedrock\n\n\nab = AnthropicBedrock(\n    aws_access_key=os.environ['AWS_ACCESS_KEY'],\n    aws_secret_key=os.environ['AWS_SECRET_KEY'],\n)\nclient = Client(models_aws[-1], ab)\n\nNow create your Chat object passing this client to the cli parameter – and from then on, everything is identical to the previous examples.\n\nchat = Chat(cli=client)\nchat(\"I'm Jeremy\")\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_bdrk_011MuMcLUba22CUttpxWuHJC\ncontent: [{‘text’: “Hello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 10, ‘output_tokens’: 36}\n\n\n\n\n\n\nGoogle Vertex\nThese are the models available through Vertex:\n\nmodels_goog\n\n('claude-3-haiku@20240307',\n 'claude-3-sonnet@20240229',\n 'claude-3-opus@20240229',\n 'claude-3-5-sonnet@20240620')\n\n\nTo use them, call AnthropicVertex with your access details, and pass that to Client:\n\nfrom anthropic import AnthropicVertex\nimport google.auth\n\n\nproject_id = google.auth.default()[1]\ngv = AnthropicVertex(project_id=project_id, region=\"us-east5\")\nclient = Client(models_goog[-1], gv)\n\n\nchat = Chat(cli=client)\nchat(\"I'm Jeremy\")\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_vrtx_015zVvSZxfmNQ8FRZjb9zPdJ\ncontent: [{‘text’: “Hello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 10, ‘output_tokens’: 36}",
    "crumbs": [
      "claudette"
    ]
  },
  {
    "objectID": "toolloop.html",
    "href": "toolloop.html",
    "title": "Tool loop",
    "section": "",
    "text": "import os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\nmodel = models[-1]\nAnthropic provides an interesting example of using tools to mock up a hypothetical ordering system. We’re going to take it a step further, and show how we can dramatically simplify the process, whilst completing more complex tasks.\nWe’ll start by defining the same mock customer/order data as in Anthropic’s example, plus create a entity relationship between customers and orders:\norders = {\n    \"O1\": dict(id=\"O1\", product=\"Widget A\", quantity=2, price=19.99, status=\"Shipped\"),\n    \"O2\": dict(id=\"O2\", product=\"Gadget B\", quantity=1, price=49.99, status=\"Processing\"),\n    \"O3\": dict(id=\"O3\", product=\"Gadget B\", quantity=2, price=49.99, status=\"Shipped\")}\n\ncustomers = {\n    \"C1\": dict(name=\"John Doe\", email=\"john@example.com\", phone=\"123-456-7890\",\n               orders=[orders['O1'], orders['O2']]),\n    \"C2\": dict(name=\"Jane Smith\", email=\"jane@example.com\", phone=\"987-654-3210\",\n               orders=[orders['O3']])\n}\nWe can now define the same functions from the original example – but note that we don’t need to manually create the large JSON schema, since Claudette handles all that for us automatically from the functions directly. We’ll add some extra functionality to update order details when cancelling too.\ndef get_customer_info(\n    customer_id:str # ID of the customer\n): # Customer's name, email, phone number, and list of orders\n    \"Retrieves a customer's information and their orders based on the customer ID\"\n    print(f'- Retrieving customer {customer_id}')\n    return customers.get(customer_id, \"Customer not found\")\n\ndef get_order_details(\n    order_id:str # ID of the order\n): # Order's ID, product name, quantity, price, and order status\n    \"Retrieves the details of a specific order based on the order ID\"\n    print(f'- Retrieving order {order_id}')\n    return orders.get(order_id, \"Order not found\")\n\ndef cancel_order(\n    order_id:str # ID of the order to cancel\n)-&gt;bool: # True if the cancellation is successful\n    \"Cancels an order based on the provided order ID\"\n    print(f'- Cancelling order {order_id}')\n    if order_id not in orders: return False\n    orders[order_id]['status'] = 'Cancelled'\n    return True\nWe’re now ready to start our chat.\ntools = [get_customer_info, get_order_details, cancel_order]\nchat = Chat(model, tools=tools)\nWe’ll start with the same request as Anthropic showed:\nr = chat('Can you tell me the email address for customer C1?')\nprint(r.stop_reason)\nr.content\n\n- Retrieving customer C1\ntool_use\n\n\n[ToolUseBlock(id='toolu_01HTEcAfuuP7P9zhn77gKtkE', input={'customer_id': 'C1'}, name='get_customer_info', type='tool_use')]\nClaude asks us to use a tool. Claudette handles that automatically by just calling it again:\nr = chat()\ncontents(r)\n\n'The email address for customer C1 is john@example.com.'\nLet’s consider a more complex case than in the original example – what happens if a customer wants to cancel all of their orders?\nchat = Chat(model, tools=tools)\nr = chat('Please cancel all orders for customer C1 for me.')\nprint(r.stop_reason)\nr.content\n\n- Retrieving customer C1\ntool_use\n\n\n[TextBlock(text=\"Okay, let's cancel all orders for customer C1:\", type='text'),\n ToolUseBlock(id='toolu_017DZK1nviVow6deBvjLYQVZ', input={'customer_id': 'C1'}, name='get_customer_info', type='tool_use')]\nThis is the start of a multi-stage tool use process. Doing it manually step by step is inconvenient, so let’s write a function to handle this for us:\nsource",
    "crumbs": [
      "Tool loop"
    ]
  },
  {
    "objectID": "toolloop.html#code-interpreter",
    "href": "toolloop.html#code-interpreter",
    "title": "Tool loop",
    "section": "Code interpreter",
    "text": "Code interpreter\nHere is an example of using toolloop to implement a simple code interpreter with additional tools.\n\nfrom toolslm.shell import get_shell\nfrom fastcore.meta import delegates\nimport traceback\n\n\n@delegates()\nclass CodeChat(Chat):\n    imps = 'os, warnings, time, json, re, math, collections, itertools, functools, dateutil, datetime, string, types, copy, pprint, enum, numbers, decimal, fractions, random, operator, typing, dataclasses'\n    def __init__(self, model: Optional[str] = None, ask:bool=True, **kwargs):\n        super().__init__(model=model, **kwargs)\n        self.ask = ask\n        self.tools.append(self.run_cell)\n        self.shell = get_shell()\n        self.shell.run_cell('import '+self.imps)\n\nWe have one additional parameter to creating a CodeChat beyond what we pass to Chat, which is ask – if that’s True, we’ll prompt the user before running code.\n\n@patch\ndef run_cell(\n    self:CodeChat,\n    code:str,   # Code to execute in persistent IPython session\n): # Result of expression on last line (if exists); '#DECLINED#' if user declines request to execute\n    \"Asks user for permission, and if provided, executes python `code` using persistent IPython session.\"\n    confirm = f'Press Enter to execute, or enter \"n\" to skip?\\n```\\n{code}\\n```\\n'\n    if self.ask and input(confirm): return '#DECLINED#'\n    try: res = self.shell.run_cell(code)\n    except Exception as e: return traceback.format_exc()\n    return res.stdout if res.result is None else res.result\n\nWe just pass along requests to run code to the shell’s implementation. Claude often prints results instead of just using the last expression, so we capture stdout in those cases.\n\nsp = f'''You are a knowledgable assistant. Do not use tools unless needed.\nDon't do complex calculations yourself -- use code for them.\nThe following modules are pre-imported for `run_cell` automatically:\n\n{CodeChat.imps}\n\nNever mention what tools you are using. Note that `run_cell` interpreter state is *persistent* across calls.\n\nIf a tool returns `#DECLINED#` report to the user that the attempt was declined and no further progress can be made.'''\n\n\ndef get_user(ignored:str='' # Unused parameter\n            ): # Username of current user\n    \"Get the username of the user running this session\"\n    return 'Jeremy'\n\nIn order to test out multi-stage tool use, we create a mock function that Claude can call to get the current username.\n\nmodel = models[-1]\n\n\nchat = CodeChat(model, tools=[get_user], sp=sp, ask=True)\n\nClaude gets confused sometimes about how tools work, so we use examples to remind it:\n\nchat.h = [\n    'Calculate the square root of `10332`', 'math.sqrt(10332)',\n    '#DECLINED#', 'I am sorry but the request to execute that was declined and no further progress can be made.'\n]\n\nProviding a callable to toolloop’s trace_func let’s us print out information during the loop:\n\ndef _show_cts(r):\n    for o in r.content:\n        if hasattr(o,'text'): print(o.text)\n        nm = getattr(o, 'name', None)\n        if nm=='run_cell': print(o.input['code'])\n        elif nm: print(f'{o.name}({o.input})')\n\n…and toolloop’s cont_func callable let’s us provide a function which, if it returns False, stops the loop:\n\ndef _cont_decline(c):\n    return nested_idx(c, 'content', 'content') != '#DECLINED#'\n\nNow we can try our code interpreter. We start by asking for a function to be created, which we’ll use in the next prompt to test that the interpreter is persistent.\n\npr = '''Create a 1-line function `checksum` for a string `s`,\nthat multiplies together the ascii values of each character in `s` using `reduce`.'''\nchat.toolloop(pr, temp=0.2, trace_func=_show_cts, cont_func=_cont_decline)\n\nPress Enter to execute, or enter \"n\" to skip?\n```\nfrom functools import reduce\n\ndef checksum(s):\n    return reduce(lambda x, y: x * ord(y), s, 1)\n```\n \nPress Enter to execute, or enter \"n\" to skip?\n```\nprint(checksum(\"hello\"))\n```\n \n\n\nHere is a 1-line function to calculate the checksum of a string using `reduce` and multiplying the ASCII values of the characters:\nfrom functools import reduce\n\ndef checksum(s):\n    return reduce(lambda x, y: x * ord(y), s, 1)\nTo test it:\nprint(checksum(\"hello\"))\nThe key steps are:\n\n1. Import `reduce` from `functools` to use the `reduce()` function.\n2. Define the `checksum()` function that takes a string `s` as input.\n3. Use `reduce()` to multiply the ASCII values (`ord(y)`) of each character `y` in the string `s`, starting with an initial value of 1.\n\nThis provides a concise one-line implementation of the checksum calculation using the `reduce()` function.\n\n\nThe key steps are:\n\nImport reduce from functools to use the reduce() function.\nDefine the checksum() function that takes a string s as input.\nUse reduce() to multiply the ASCII values (ord(y)) of each character y in the string s, starting with an initial value of 1.\n\nThis provides a concise one-line implementation of the checksum calculation using the reduce() function.\n\n\nid: msg_01HPVguuAVn2P7Fiqf5bu3Ap\ncontent: [{‘text’: ‘The key steps are:. Import reduce from functools to use the reduce() function.. Define the checksum() function that takes a string s as input.. Use reduce() to multiply the ASCII values (ord(y)) of each character y in the string s, starting with an initial value of 1.provides a concise one-line implementation of the checksum calculation using the reduce() function.’, ‘type’: ‘text’}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 880, ‘output_tokens’: 114}\n\n\n\n\nBy asking for a calculation to be done on the username, we force it to use multiple steps:\n\npr = 'Use it to get the checksum of the username of this session.'\nchat.toolloop(pr, temp=0.2, trace_func=_show_cts)\n\nOkay, let's get the checksum of the username for this session:\nget_user({'ignored': 'ignored'})\nfrom functools import reduce\n\ndef checksum(s):\n    return reduce(lambda x, y: x * ord(y), s, 1)\n\nprint(checksum(\"Jeremy\"))\nThe checksum of the username \"Jeremy\" is 1134987783204.\n\n\nPress Enter to execute, or enter \"n\" to skip?\n```\nfrom functools import reduce\n\ndef checksum(s):\n    return reduce(lambda x, y: x * ord(y), s, 1)\n\nprint(checksum(\"Jeremy\"))\n```\n \n\n\nThe checksum of the username “Jeremy” is 1134987783204.\n\n\nid: msg_011VDiCPXRHa2XkkyS1hGEPB\ncontent: [{‘text’: ‘The checksum of the username “Jeremy” is 1134987783204.’, ‘type’: ‘text’}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 1204, ‘output_tokens’: 21}",
    "crumbs": [
      "Tool loop"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Claudette’s source",
    "section": "",
    "text": "This is the ‘literate’ source code for Claudette. You can view the fully rendered version of the notebook here, or you can clone the git repo and run the interactive notebook in Jupyter. The notebook is converted the Python module claudette/core.py using nbdev. The goal of this source code is to both create the Python module, and also to teach the reader how it is created, without assuming much existing knowledge about Claude’s API.\nMost of the time you’ll see that we write some source code first, and then a description or discussion of it afterwards.",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#setup",
    "href": "core.html#setup",
    "title": "Claudette’s source",
    "section": "Setup",
    "text": "Setup\n\nimport os\n# os.environ['ANTHROPIC_LOG'] = 'debug'\n\nTo print every HTTP request and response in full, uncomment the above line. This functionality is provided by Anthropic’s SDK.\n\n\n\n\n\n\nTip\n\n\n\nIf you’re reading the rendered version of this notebook, you’ll see an “Exported source” collapsible widget below. If you’re reading the source notebook directly, you’ll see #| exports at the top of the cell. These show that this piece of code will be exported into the python module that this notebook creates. No other code will be included – any other code in this notebook is just for demonstration, documentation, and testing.\nYou can toggle expanding/collapsing the source code of all exported sections by using the &lt;/&gt; Code menu in the top right of the rendered notebook page.\n\n\n\n\nExported source\nmodels = 'claude-3-opus-20240229','claude-3-5-sonnet-20240620','claude-3-haiku-20240307'\n\n\nThese are the current versions of Anthropic’s model at the time of writing.\n\nmodel = models[1]\n\nFor examples, we’ll use Sonnet 3.5, since it’s awesome.",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#antropic-sdk",
    "href": "core.html#antropic-sdk",
    "title": "Claudette’s source",
    "section": "Antropic SDK",
    "text": "Antropic SDK\n\ncli = Anthropic()\n\nThis is what Anthropic’s SDK provides for interacting with Python. To use it, pass it a list of messages, with content and a role. The roles should alternate between user and assistant.\n\n\n\n\n\n\nTip\n\n\n\nAfter the code below you’ll see an indented section with an orange vertical line on the left. This is used to show the result of running the code above. Because the code is running in a Jupyter Notebook, we don’t have to use print to display results, we can just type the expression directly, as we do with r here.\n\n\n\nm = {'role': 'user', 'content': \"I'm Jeremy\"}\nr = cli.messages.create(messages=[m], model=model, max_tokens=100)\nr\n\nMessage(id='msg_01RjWdAktoZPidk5mZoXRRZL', content=[TextBlock(text=\"Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?\", type='text')], model='claude-3-5-sonnet-20240620', role='assistant', stop_reason='end_turn', stop_sequence=None, type='message', usage=Usage(input_tokens=10, output_tokens=23))\n\n\n\nFormatting output\nThat output is pretty long and hard to read, so let’s clean it up. We’ll start by pulling out the Content part of the message. To do that, we’re going to write our first function which will be included to the claudette/core.py module.\n\n\n\n\n\n\nTip\n\n\n\nThis is the first exported public function or class we’re creating (the previous export was of a variable). In the rendered version of the notebook for these you’ll see 4 things, in this order (unless the symbol starts with a single _, which indicates it’s private):\n\nThe signature (with the symbol name as a heading, with a horizontal rule above)\nA table of paramater docs (if provided)\nThe doc string (in italics).\nThe source code (in a collapsible “Exported source” block)\n\nAfter that, we generally provide a bit more detail on what we’ve created, and why, along with a sample usage.\n\n\n\nsource\n\n\nfind_block\n\n find_block (r:collections.abc.Mapping, blk_type:type=&lt;class\n             'anthropic.types.text_block.TextBlock'&gt;)\n\nFind the first block of type blk_type in r.content.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nr\nMapping\n\nThe message to look in\n\n\nblk_type\ntype\nTextBlock\nThe type of block to find\n\n\n\n\n\nExported source\ndef find_block(r:abc.Mapping, # The message to look in\n               blk_type:type=TextBlock  # The type of block to find\n              ):\n    \"Find the first block of type `blk_type` in `r.content`.\"\n    return first(o for o in r.content if isinstance(o,blk_type))\n\n\nThis makes it easier to grab the needed parts of Claude’s responses, which can include multiple pieces of content. By default, we look for the first text block. That will generally have the content we want to display.\n\nfind_block(r)\n\nTextBlock(text=\"Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?\", type='text')\n\n\n\nsource\n\n\ncontents\n\n contents (r)\n\nHelper to get the contents from Claude response r.\n\n\nExported source\ndef contents(r):\n    \"Helper to get the contents from Claude response `r`.\"\n    blk = find_block(r)\n    if not blk and r.content: blk = r.content[0]\n    return blk.text.strip() if hasattr(blk,'text') else blk\n\n\nFor display purposes, we often just want to show the text itself.\n\ncontents(r)\n\n\"Hello Jeremy! It's nice to meet you. Is there anything I can help you with today?\"\n\n\n\n\nExported source\n@patch\ndef _repr_markdown_(self:(Message)):\n    det = '\\n- '.join(f'{k}: {v}' for k,v in self.model_dump().items())\n    return f\"\"\"{contents(self)}\n\n&lt;details&gt;\n\n- {det}\n\n&lt;/details&gt;\"\"\"\n\n\nJupyter looks for a _repr_markdown_ method in displayed objects; we add this in order to display just the content text, and collapse full details into a hideable section. Note that patch is from fastcore, and is used to add (or replace) functionality in an existing class. We pass the class(es) that we want to patch as type annotations to self. In this case, _repr_markdown_ is being added to Anthropic’s Message class, so when we display the message now we just see the contents, and the details are hidden away in a collapsible details block.\n\nr\n\nHello Jeremy! It’s nice to meet you. Is there anything I can help you with today?\n\n\nid: msg_01RjWdAktoZPidk5mZoXRRZL\ncontent: [{‘text’: “Hello Jeremy! It’s nice to meet you. Is there anything I can help you with today?”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 10, ‘output_tokens’: 23}\n\n\n\n\nOne key part of the response is the usage key, which tells us how many tokens we used by returning a Usage object.\nWe’ll add some helpers to make things a bit cleaner for creating and formatting these objects.\n\nr.usage\n\nUsage(input_tokens=10, output_tokens=23)\n\n\n\nsource\n\n\nusage\n\n usage (inp=0, out=0)\n\nSlightly more concise version of Usage.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninp\nint\n0\nNumber of input tokens\n\n\nout\nint\n0\nNumber of output tokens\n\n\n\n\n\nExported source\ndef usage(inp=0, # Number of input tokens\n          out=0  # Number of output tokens\n         ):\n    \"Slightly more concise version of `Usage`.\"\n    return Usage(input_tokens=inp, output_tokens=out)\n\n\nThe constructor provided by Anthropic is rather verbose, so we clean it up a bit, using a lowercase version of the name.\n\nusage(5)\n\nUsage(input_tokens=5, output_tokens=0)\n\n\n\nsource\n\n\nUsage.total\n\n Usage.total ()\n\n\n\nExported source\n@patch(as_prop=True)\ndef total(self:Usage): return self.input_tokens+self.output_tokens\n\n\nAdding a total property to Usage makes it easier to see how many tokens we’ve used up altogether.\n\nusage(5,1).total\n\n6\n\n\n\nsource\n\n\nUsage.__repr__\n\n Usage.__repr__ ()\n\nReturn repr(self).\n\n\nExported source\n@patch\ndef __repr__(self:Usage): return f'In: {self.input_tokens}; Out: {self.output_tokens}; Total: {self.total}'\n\n\nIn python, patching __repr__ lets us change how an object is displayed. (More generally, methods starting and ending in __ in Python are called dunder methods, and have some magic behavior – such as, in this case, changing how an object is displayed.)\n\nr.usage\n\nIn: 10; Out: 23; Total: 33\n\n\n\nsource\n\n\nUsage.__add__\n\n Usage.__add__ (b)\n\nAdd together each of input_tokens and output_tokens\n\n\nExported source\n@patch\ndef __add__(self:Usage, b):\n    \"Add together each of `input_tokens` and `output_tokens`\"\n    return usage(self.input_tokens+b.input_tokens, self.output_tokens+b.output_tokens)\n\n\nAnd, patching __add__ lets + work on a Usage object.\n\nr.usage+r.usage\n\nIn: 20; Out: 46; Total: 66\n\n\n\n\nCreating messages\nCreating correctly formatted dicts from scratch every time isn’t very handy, so next up we’ll add helpers for this.\n\ndef mk_msg(content, role='user', **kw):\n    return dict(role=role, content=content, **kw)\n\nWe make things a bit more convenient by writing a function to create a message for us.\n\n\n\n\n\n\nNote\n\n\n\nYou may have noticed that we didn’t export the mk_msg function (i.e. there’s no “Exported source” block around it). That’s because we’ll need more functionality in our final version than this version has – so we’ll be defining a more complete version later. Rather than refactoring/editing in notebooks, often it’s helpful to simply gradually build up complexity by re-defining a symbol.\n\n\n\nprompt = \"I'm Jeremy\"\nm = mk_msg(prompt)\nm\n\n{'role': 'user', 'content': \"I'm Jeremy\"}\n\n\n\nr = cli.messages.create(messages=[m], model=model, max_tokens=100)\nr\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to chat about or any questions you have?\n\n\nid: msg_01TDkKPNLXoSK8DCPuyP37hX\ncontent: [{‘text’: “Hello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to chat about or any questions you have?”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 10, ‘output_tokens’: 36}\n\n\n\n\n\nsource\n\n\nmk_msgs\n\n mk_msgs (msgs:list, **kw)\n\nHelper to set ‘assistant’ role on alternate messages.\n\n\nExported source\ndef mk_msgs(msgs:list, **kw):\n    \"Helper to set 'assistant' role on alternate messages.\"\n    if isinstance(msgs,str): msgs=[msgs]\n    return [mk_msg(o, ('user','assistant')[i%2], **kw) for i,o in enumerate(msgs)]\n\n\nLLMs, including Claude, don’t actually have state, but instead dialogs are created by passing back all previous prompts and responses every time. With Claude, they always alternate user and assistant. Therefore we create a function to make it easier to build up these dialog lists.\nBut to do so, we need to update mk_msg so that we can’t only pass a str as content, but can also pass a dict or an object with a content attr, since these are both types of message that Claude can create. To do so, we check for a content key or attr, and use it if found.\n\ndef mk_msg(content, role='user', **kw):\n    \"Helper to create a `dict` appropriate for a Claude message. `kw` are added as key/value pairs to the message\"\n    if hasattr(content, 'content'): content,role = content.content,content.role\n    if isinstance(content, abc.Mapping): content=content['content']\n    return dict(role=role, content=content, **kw)\n\n\nmsgs = mk_msgs([prompt, r, 'I forgot my name. Can you remind me please?'])\nmsgs\n\n[{'role': 'user', 'content': \"I'm Jeremy\"},\n {'role': 'assistant',\n  'content': [TextBlock(text=\"Hello Jeremy! It's nice to meet you. How can I assist you today? Is there anything specific you'd like to chat about or any questions you have?\", type='text')]},\n {'role': 'user', 'content': 'I forgot my name. Can you remind me please?'}]\n\n\nNow, if we pass this list of messages to Claude, the model treats it as a conversation to respond to.\n\ncli.messages.create(messages=msgs, model=model, max_tokens=200)\n\nOf course! You just introduced yourself as Jeremy. That’s your name.\n\n\nid: msg_014avFgGrLozDLLtVPy6BerE\ncontent: [{‘text’: “Of course! You just introduced yourself as Jeremy. That’s your name.”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 60, ‘output_tokens’: 18}",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#client",
    "href": "core.html#client",
    "title": "Claudette’s source",
    "section": "Client",
    "text": "Client\n\nsource\n\nClient\n\n Client (model, cli=None)\n\nBasic Anthropic messages client.\n\n\nExported source\nclass Client:\n    def __init__(self, model, cli=None):\n        \"Basic Anthropic messages client.\"\n        self.model,self.use = model,usage()\n        self.c = (cli or Anthropic())\n\n\nWe’ll create a simple Client for Anthropic which tracks usage stores the model to use. We don’t add any methods right away – instead we’ll use patch for that so we can add and document them incrementally.\n\nc = Client(model)\nc.use\n\nIn: 0; Out: 0; Total: 0\n\n\n\n\nExported source\n@patch\ndef _r(self:Client, r:Message, prefill=''):\n    \"Store the result of the message and accrue total usage.\"\n    if prefill:\n        blk = find_block(r)\n        blk.text = prefill + (blk.text or '')\n    self.result = r\n    self.use += r.usage\n    return r\n\n\nWe use a _ prefix on private methods, but we document them here in the interests of literate source code.\n_r will be used each time we get a new result, to track usage and also to keep the result available for later.\n\nc._r(r)\nc.use\n\nIn: 10; Out: 36; Total: 46\n\n\nWhereas OpenAI’s models use a stream parameter for streaming, Anthropic’s use a separate method. We implement Anthropic’s approach in a private method, and then use a stream parameter in __call__ for consistency:\n\n\nExported source\n@patch\ndef _stream(self:Client, msgs:list, prefill='', **kwargs):\n    with self.c.messages.stream(model=self.model, messages=mk_msgs(msgs), **kwargs) as s:\n        if prefill: yield(prefill)\n        yield from s.text_stream\n        self._r(s.get_final_message(), prefill)\n\n\nClaude supports adding an extra assistant message at the end, which contains the prefill – i.e. the text we want Claude to assume the response starts with. However Claude doesn’t actually repeat that in the response, so for convenience we add it.\n\nsource\n\n\nClient.__call__\n\n Client.__call__ (msgs:list, sp='', temp=0, maxtok=4096, prefill='',\n                  stream:bool=False, metadata:message_create_params.Metada\n                  ta|NotGiven=NOT_GIVEN,\n                  stop_sequences:List[str]|NotGiven=NOT_GIVEN, system:Unio\n                  n[str,Iterable[TextBlockParam]]|NotGiven=NOT_GIVEN,\n                  temperature:float|NotGiven=NOT_GIVEN, tool_choice:messag\n                  e_create_params.ToolChoice|NotGiven=NOT_GIVEN,\n                  tools:Iterable[ToolParam]|NotGiven=NOT_GIVEN,\n                  top_k:int|NotGiven=NOT_GIVEN,\n                  top_p:float|NotGiven=NOT_GIVEN,\n                  extra_headers:Headers|None=None,\n                  extra_query:Query|None=None, extra_body:Body|None=None,\n                  timeout:float|httpx.Timeout|None|NotGiven=600)\n\nMake a call to Claude.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmsgs\nlist\n\nList of messages in the dialog\n\n\nsp\nstr\n\nThe system prompt\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nstream\nbool\nFalse\nStream response?\n\n\nmetadata\nmessage_create_params.Metadata | NotGiven\nNOT_GIVEN\n\n\n\nstop_sequences\nList[str] | NotGiven\nNOT_GIVEN\n\n\n\nsystem\nUnion[str, Iterable[TextBlockParam]] | NotGiven\nNOT_GIVEN\n\n\n\ntemperature\nfloat | NotGiven\nNOT_GIVEN\n\n\n\ntool_choice\nmessage_create_params.ToolChoice | NotGiven\nNOT_GIVEN\n\n\n\ntools\nIterable[ToolParam] | NotGiven\nNOT_GIVEN\n\n\n\ntop_k\nint | NotGiven\nNOT_GIVEN\n\n\n\ntop_p\nfloat | NotGiven\nNOT_GIVEN\n\n\n\nextra_headers\nHeaders | None\nNone\n\n\n\nextra_query\nQuery | None\nNone\n\n\n\nextra_body\nBody | None\nNone\n\n\n\ntimeout\nfloat | httpx.Timeout | None | NotGiven\n600\n\n\n\n\n\n\nExported source\n@patch\n@delegates(messages.Messages.create)\ndef __call__(self:Client,\n             msgs:list, # List of messages in the dialog\n             sp='', # The system prompt\n             temp=0, # Temperature\n             maxtok=4096, # Maximum tokens\n             prefill='', # Optional prefill to pass to Claude as start of its response\n             stream:bool=False, # Stream response?\n             **kwargs):\n    \"Make a call to Claude.\"\n    pref = [prefill.strip()] if prefill else []\n    if not isinstance(msgs,list): msgs = [msgs]\n    msgs = mk_msgs(msgs+pref)\n    if stream: return self._stream(msgs, prefill=prefill, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    res = self.c.messages.create(\n        model=self.model, messages=msgs, max_tokens=maxtok, system=sp, temperature=temp, **kwargs)\n    self._r(res, prefill)\n    return self.result\n\n\nDefining __call__ let’s us use an object like a function (i.e it’s callable). We use it as a small wrapper over messages.create.\n\nc = Client(model)\nc.use\n\nIn: 0; Out: 0; Total: 0\n\n\n\nc.model = models[-1]\n\n\nc('Hi')\n\nHello! How can I assist you today?\n\n\nid: msg_01Ds4j94G5j51jVdY5aJKPsc\ncontent: [{‘text’: ‘Hello! How can I assist you today?’, ‘type’: ‘text’}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 8, ‘output_tokens’: 12}\n\n\n\n\n\nc.use\n\nIn: 8; Out: 12; Total: 20\n\n\nLet’s try out prefill:\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\n\n\nc(q, prefill=pref)\n\nAccording to Douglas Adams, “The answer to the ultimate question of life, the universe, and everything is 42.”\n\n\nid: msg_01RQ9JXwWi8ncwhwTJBtncKB\ncontent: [{‘text’: ‘According to Douglas Adams, “The answer to the ultimate question of life, the universe, and everything is 42.”’, ‘type’: ‘text’}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 24, ‘output_tokens’: 23}\n\n\n\n\nWe can pass stream=True to stream the response back incrementally:\n\nfor o in c('Hi', stream=True): print(o, end='')\n\nHello! How can I assist you today?\n\n\n\nc.use\n\nIn: 40; Out: 47; Total: 87\n\n\n\nfor o in c(q, prefill=pref, stream=True): print(o, end='')\n\nAccording to Douglas Adams,  \"The answer to the ultimate question of life, the universe, and everything is 42.\"\n\n\n\nc.use\n\nIn: 64; Out: 70; Total: 134",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#tool-use",
    "href": "core.html#tool-use",
    "title": "Claudette’s source",
    "section": "Tool use",
    "text": "Tool use\nLet’s now add tool use (aka function calling).\n\nsource\n\nmk_tool_choice\n\n mk_tool_choice (choose:Union[str,bool,NoneType])\n\nCreate a tool_choice dict that’s ‘auto’ if choose is None, ‘any’ if it is True, or ‘tool’ otherwise\n\n\nExported source\ndef mk_tool_choice(choose:Union[str,bool,None])-&gt;dict:\n    \"Create a `tool_choice` dict that's 'auto' if `choose` is `None`, 'any' if it is True, or 'tool' otherwise\"\n    return {\"type\": \"tool\", \"name\": choose} if isinstance(choose,str) else {'type':'any'} if choose else {'type':'auto'}\n\n\n\nprint(mk_tool_choice('sums'))\nprint(mk_tool_choice(True))\nprint(mk_tool_choice(None))\n\n{'type': 'tool', 'name': 'sums'}\n{'type': 'any'}\n{'type': 'auto'}\n\n\nClaude can be forced to use a particular tool, or select from a specific list of tools, or decide for itself when to use a tool. If you want to force a tool (or force choosing from a list), include a tool_choice param with a dict from mk_tool_choice.\nFor testing, we need a function that Claude can call; we’ll write a simple function that adds numbers together, and will tell us when it’s being called:\n\ndef sums(\n    a:int,  # First thing to sum\n    b:int=1 # Second thing to sum\n) -&gt; int: # The sum of the inputs\n    \"Adds a + b.\"\n    print(f\"Finding the sum of {a} and {b}\")\n    return a + b\n\n\na,b = 604542,6458932\npr = f\"What is {a}+{b}?\"\nsp = \"You are a summing expert.\"\n\nClaudette can autogenerate a schema thanks to the toolslm library. We’ll force the use of the tool using the function we created earlier.\n\ntools=[get_schema(sums)]\nchoice = mk_tool_choice('sums')\n\nWe’ll start a dialog with Claude now. We’ll store the messages of our dialog in msgs. The first message will be our prompt pr, and we’ll pass our tools schema.\n\nmsgs = mk_msgs(pr)\nr = c(msgs, sp=sp, tools=tools, tool_choice=choice)\nr\n\nToolUseBlock(id=‘toolu_01HeytuCw3qJvHQdoqvR7DzV’, input={‘a’: 604542, ‘b’: 6458932}, name=‘sums’, type=‘tool_use’)\n\n\nid: msg_01XdZdVPohkqoC9VbBAdkbFS\ncontent: [{‘id’: ‘toolu_01HeytuCw3qJvHQdoqvR7DzV’, ‘input’: {‘a’: 604542, ‘b’: 6458932}, ‘name’: ‘sums’, ‘type’: ‘tool_use’}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 493, ‘output_tokens’: 53}\n\n\n\n\nWhen Claude decides that it should use a tool, it passes back a ToolUseBlock with the name of the tool to call, and the params to use.\nWe don’t want to allow it to call just any possible function (that would be a security disaster!) so we create a namespace – that is, a dictionary of allowable function names to call.\n\n\nExported source\ndef _mk_ns(*funcs:list[callable]) -&gt; dict[str,callable]:\n    \"Create a `dict` of name to function in `funcs`, to use as a namespace\"\n    return {f.__name__:f for f in funcs}\n\n\n\nns = _mk_ns(sums)\nns\n\n{'sums': &lt;function __main__.sums(a: int, b: int = 1) -&gt; int&gt;}\n\n\n\nsource\n\n\ncall_func\n\n call_func (fc:anthropic.types.tool_use_block.ToolUseBlock,\n            ns:Optional[collections.abc.Mapping]=None, obj:Optional=None)\n\nCall the function in the tool response tr, using namespace ns.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfc\nToolUseBlock\n\nTool use block from Claude’s message\n\n\nns\nOptional\nNone\nNamespace to search for tools, defaults to globals()\n\n\nobj\nOptional\nNone\nObject to search for tools\n\n\n\n\n\nExported source\ndef call_func(fc:ToolUseBlock, # Tool use block from Claude's message\n              ns:Optional[abc.Mapping]=None, # Namespace to search for tools, defaults to `globals()`\n              obj:Optional=None # Object to search for tools\n             ):\n    \"Call the function in the tool response `tr`, using namespace `ns`.\"\n    if ns is None: ns=globals()\n    if not isinstance(ns, abc.Mapping): ns = _mk_ns(*ns)\n    func = getattr(obj, fc.name, None)\n    if not func: func = ns[fc.name]\n    res = func(**fc.input)\n    return dict(type=\"tool_result\", tool_use_id=fc.id, content=str(res))\n\n\nWe can now use the function requested by Claude. We look it up in ns, and pass in the provided parameters.\n\nfc = find_block(r, ToolUseBlock)\nres = call_func(fc, ns=ns)\nres\n\nFinding the sum of 604542 and 6458932\n\n\n{'type': 'tool_result',\n 'tool_use_id': 'toolu_01HeytuCw3qJvHQdoqvR7DzV',\n 'content': '7063474'}\n\n\n\nsource\n\n\nmk_toolres\n\n mk_toolres (r:collections.abc.Mapping,\n             ns:Optional[collections.abc.Mapping]=None, obj:Optional=None)\n\nCreate a tool_result message from response r.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nr\nMapping\n\nTool use request response from Claude\n\n\nns\nOptional\nNone\nNamespace to search for tools\n\n\nobj\nOptional\nNone\nClass to search for tools\n\n\n\n\n\nExported source\ndef mk_toolres(\n    r:abc.Mapping, # Tool use request response from Claude\n    ns:Optional[abc.Mapping]=None, # Namespace to search for tools\n    obj:Optional=None # Class to search for tools\n    ):\n    \"Create a `tool_result` message from response `r`.\"\n    cts = getattr(r, 'content', [])\n    res = [mk_msg(r)]\n    tcs = [call_func(o, ns=ns, obj=obj) for o in cts if isinstance(o,ToolUseBlock)]\n    if tcs: res.append(mk_msg(tcs))\n    return res\n\n\nIn order to tell Claude the result of the tool call, we pass back the tool use assistant request and the tool_result response.\n\ntr = mk_toolres(r, ns=ns)\ntr\n\nFinding the sum of 604542 and 6458932\n\n\n[{'role': 'assistant',\n  'content': [ToolUseBlock(id='toolu_01HeytuCw3qJvHQdoqvR7DzV', input={'a': 604542, 'b': 6458932}, name='sums', type='tool_use')]},\n {'role': 'user',\n  'content': [{'type': 'tool_result',\n    'tool_use_id': 'toolu_01HeytuCw3qJvHQdoqvR7DzV',\n    'content': '7063474'}]}]\n\n\nWe add this to our dialog, and now Claude has all the information it needs to answer our question.\n\nmsgs += tr\ncontents(c(msgs, sp=sp, tools=tools))\n\n'The sum of 604542 and 6458932 is 7063474.'\n\n\nThis works with methods as well – in this case, use the object itself for ns:\n\nclass Dummy:\n    def sums(\n        self,\n        a:int,  # First thing to sum\n        b:int=1 # Second thing to sum\n    ) -&gt; int: # The sum of the inputs\n        \"Adds a + b.\"\n        print(f\"Finding the sum of {a} and {b}\")\n        return a + b\n\n\ntools = [get_schema(Dummy.sums)]\no = Dummy()\n\nmsgs = mk_msgs(pr)\nr = c(msgs, sp=sp, tools=tools, tool_choice=choice)\ntr = mk_toolres(r, obj=o)\nmsgs += tr\ncontents(c(msgs, sp=sp, tools=tools))\n\nFinding the sum of 604542 and 6458932\n\n\n'The sum of 604542 and 6458932 is 7063474.'",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#chat",
    "href": "core.html#chat",
    "title": "Claudette’s source",
    "section": "Chat",
    "text": "Chat\nRather than manually adding the responses to a dialog, we’ll create a simple Chat class to do that for us, each time we make a request. We’ll also store the system prompt and tools here, to avoid passing them every time.\n\nsource\n\nChat\n\n Chat (model:Optional[str]=None, cli:Optional[__main__.Client]=None,\n       sp='', tools:Optional[list]=None, tool_choice:Optional[dict]=None)\n\nAnthropic chat client.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nmodel\nOptional\nNone\nModel to use (leave empty if passing cli)\n\n\ncli\nOptional\nNone\nClient to use (leave empty if passing model)\n\n\nsp\nstr\n\nOptional system prompt\n\n\ntools\nOptional\nNone\nList of tools to make available to Claude\n\n\ntool_choice\nOptional\nNone\nOptionally force use of some tool\n\n\n\n\n\nExported source\nclass Chat:\n    def __init__(self,\n                 model:Optional[str]=None, # Model to use (leave empty if passing `cli`)\n                 cli:Optional[Client]=None, # Client to use (leave empty if passing `model`)\n                 sp='', # Optional system prompt\n                 tools:Optional[list]=None, # List of tools to make available to Claude\n                 tool_choice:Optional[dict]=None): # Optionally force use of some tool\n        \"Anthropic chat client.\"\n        assert model or cli\n        self.c = (cli or Client(model))\n        self.h,self.sp,self.tools,self.tool_choice = [],sp,tools,tool_choice\n\n    @property\n    def use(self): return self.c.use\n\n\nThe class stores the Client that will provide the responses in c, and a history of messages in h.\n\nsp = \"Never mention what tools you use.\"\nchat = Chat(model, sp=sp)\nchat.c.use, chat.h\n\n(In: 0; Out: 0; Total: 0, [])\n\n\n\nsource\n\n\nChat.__call__\n\n Chat.__call__ (pr=None, temp=0, maxtok=4096, stream=False, prefill='',\n                **kw)\n\nCall self as a function.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\npr\nNoneType\nNone\nPrompt / message\n\n\ntemp\nint\n0\nTemperature\n\n\nmaxtok\nint\n4096\nMaximum tokens\n\n\nstream\nbool\nFalse\nStream response?\n\n\nprefill\nstr\n\nOptional prefill to pass to Claude as start of its response\n\n\nkw\n\n\n\n\n\n\n\n\nExported source\n@patch\ndef _stream(self:Chat, res):\n    yield from res\n    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)\n\n\n\n\nExported source\n@patch\ndef __call__(self:Chat,\n             pr=None,  # Prompt / message\n             temp=0, # Temperature\n             maxtok=4096, # Maximum tokens\n             stream=False, # Stream response?\n             prefill='', # Optional prefill to pass to Claude as start of its response\n             **kw):\n    if pr and self.h and nested_idx(self.h, -1, 'role')=='user':\n        self() # There's already a user request pending, so complete it\n    if pr: self.h.append(mk_msg(pr))\n    if self.tools: kw['tools'] = [get_schema(o) for o in self.tools]\n    if self.tool_choice: kw['tool_choice'] = mk_tool_choice(self.tool_choice)\n    res = self.c(self.h, stream=stream, prefill=prefill, sp=self.sp, temp=temp, maxtok=maxtok, **kw)\n    if stream: return self._stream(res)\n    self.h += mk_toolres(self.c.result, ns=self.tools, obj=self)\n    return res\n\n\nThe __call__ method just passes the request along to the Client, but rather than just passing in this one prompt, it appends it to the history and passes it all along. As a result, we now have state!\n\nchat(\"I'm Jeremy\")\nchat(\"What's my name?\")\n\nYour name is Jeremy, as you mentioned in your previous message.\n\n\nid: msg_01HGKL13BqSvzz7q42ub79ra\ncontent: [{‘text’: ‘Your name is Jeremy, as you mentioned in your previous message.’, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 64, ‘output_tokens’: 16}\n\n\n\n\nLet’s try out prefill too:\n\nq = \"Concisely, what is the meaning of life?\"\npref = 'According to Douglas Adams,'\n\n\nchat(q, prefill=pref)\n\nAccording to Douglas Adams, the meaning of life is 42. More seriously, there’s no universally agreed upon answer. Common philosophical perspectives include:\n\nFinding personal fulfillment\nServing others\nPursuing happiness\nCreating meaning through our choices\nExperiencing and appreciating existence\n\nUltimately, many believe each individual must determine their own life’s meaning.\n\n\nid: msg_01TghsukVRvHiZdCoX1WxSHH\ncontent: [{‘text’: “According to Douglas Adams, the meaning of life is 42. More seriously, there’s no universally agreed upon answer. Common philosophical perspectives include:. Finding personal fulfillment. Serving others. Pursuing happiness. Creating meaning through our choices. Experiencing and appreciating existence, many believe each individual must determine their own life’s meaning.”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 100, ‘output_tokens’: 82}\n\n\n\n\n\nchat = Chat(model, sp=sp)\nfor o in chat(\"I'm Jeremy\", stream=True): print(o, end='')\n\nHello Jeremy! It's nice to meet you. How are you doing today? Is there anything in particular you'd like to chat about or any questions I can help you with?\n\n\n\nfor o in chat(q, prefill=pref, stream=True): print(o, end='')\n\nAccording to Douglas Adams,  the meaning of life is 42. More seriously, there's no universally agreed upon answer. Common philosophical perspectives include:\n\n1. Finding personal fulfillment\n2. Serving others\n3. Pursuing happiness\n4. Creating meaning through our choices\n5. Experiencing and appreciating existence\n\nUltimately, many believe each individual must determine their own meaning.\n\n\n\n\nChat tool use\nWe automagically get streamlined tool use as well:\n\npr = f\"What is {a}+{b}?\"\npr\n\n'What is 604542+6458932?'\n\n\n\nchat = Chat(model, sp=sp, tools=[sums])\nr = chat(pr)\nr\n\nFinding the sum of 604542 and 6458932\n\n\nTo answer this question, I can use the “sums” function to add these two numbers together. Let me do that for you.\n\n\nid: msg_01WxUoaTJ3dAyhjEYLvc9EnY\ncontent: [{‘text’: ‘To answer this question, I can use the “sums” function to add these two numbers together. Let me do that for you.’, ‘type’: ‘text’}, {‘id’: ‘toolu_01DXhNKYAdSfE6emyf3dXMWU’, ‘input’: {‘a’: 604542, ‘b’: 6458932}, ‘name’: ‘sums’, ‘type’: ‘tool_use’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: tool_use\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 428, ‘output_tokens’: 101}\n\n\n\n\n\nchat()\n\nThe sum of 604542 and 6458932 is 7063474.\n\n\nid: msg_011NE19yxPQcTy7zSb9814P6\ncontent: [{‘text’: ‘The sum of 604542 and 6458932 is 7063474.’, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 543, ‘output_tokens’: 23}\n\n\n\n\nIt should be correct, because it actually used our Python function to do the addition. Let’s check:\n\na+b\n\n7063474",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#images",
    "href": "core.html#images",
    "title": "Claudette’s source",
    "section": "Images",
    "text": "Images\nClaude can handle image data as well. As everyone knows, when testing image APIs you have to use a cute puppy.\n\n# Image is Cute_dog.jpg from Wikimedia\nfn = Path('samples/puppy.jpg')\ndisplay.Image(filename=fn, width=200)\n\n\n\n\n\n\n\n\n\nimg = fn.read_bytes()\n\n\nsource\n\nimg_msg\n\n img_msg (data:bytes)\n\nConvert image data into an encoded dict\n\n\nExported source\ndef img_msg(data:bytes)-&gt;dict:\n    \"Convert image `data` into an encoded `dict`\"\n    img = base64.b64encode(data).decode(\"utf-8\")\n    mtype = mimetypes.types_map['.'+imghdr.what(None, h=data)]\n    r = dict(type=\"base64\", media_type=mtype, data=img)\n    return {\"type\": \"image\", \"source\": r}\n\n\nAnthropic have documented the particular dict structure that expect image data to be in, so we have a little function to create that for us.\n\nsource\n\n\ntext_msg\n\n text_msg (s:str)\n\nConvert s to a text message\n\n\nExported source\ndef text_msg(s:str)-&gt;dict:\n    \"Convert `s` to a text message\"\n    return {\"type\": \"text\", \"text\": s}\n\n\nA Claude message can be a list of image and text parts. So we’ve also created a helper for making the text parts.\n\nq = \"In brief, what color flowers are in this image?\"\nmsg = mk_msg([img_msg(img), text_msg(q)])\n\n\nc([msg])\n\nThe image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.\n\n\nid: msg_01R34q46R6yfr1vAGuDQT1t7\ncontent: [{‘text’: ‘The image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.’, ‘type’: ‘text’}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 110, ‘output_tokens’: 28}\n\n\n\n\n\n\nExported source\ndef _mk_content(src):\n    \"Create appropriate content data structure based on type of content\"\n    if isinstance(src,str): return text_msg(src)\n    if isinstance(src,bytes): return img_msg(src)\n    return src\n\n\nThere’s not need to manually choose the type of message, since we figure that out from the data of the source data.\n\n_mk_content('Hi')\n\n{'type': 'text', 'text': 'Hi'}\n\n\n\nsource\n\n\nmk_msg\n\n mk_msg (content, role='user', **kw)\n\nHelper to create a dict appropriate for a Claude message. kw are added as key/value pairs to the message\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncontent\n\n\nA string, list, or dict containing the contents of the message\n\n\nrole\nstr\nuser\nMust be ‘user’ or ‘assistant’\n\n\nkw\n\n\n\n\n\n\n\n\nExported source\ndef mk_msg(content, # A string, list, or dict containing the contents of the message\n           role='user', # Must be 'user' or 'assistant'\n           **kw):\n    \"Helper to create a `dict` appropriate for a Claude message. `kw` are added as key/value pairs to the message\"\n    if hasattr(content, 'content'): content,role = content.content,content.role\n    if isinstance(content, abc.Mapping): content=content['content']\n    if not isinstance(content, list): content=[content]\n    content = [_mk_content(o) for o in content] if content else '.'\n    return dict(role=role, content=content, **kw)\n\n\nWhen we construct a message, we now use _mk_content to create the appropriate parts. Since a dialog contains multiple messages, and a message can contain multiple content parts, to pass a single message with multiple parts we have to use a list containing a single list:\n\nc([[img, q]])\n\nThe image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.\n\n\nid: msg_01DxDS3ZXKsshFFaQ7KDePXq\ncontent: [{‘text’: ‘The image contains purple or lavender-colored flowers, which appear to be daisies or a similar type of flower.’, ‘type’: ‘text’}]\nmodel: claude-3-haiku-20240307\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 110, ‘output_tokens’: 28}\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nAs promised (much!) earlier, we’ve now finally completed our definition of mk_msg, and this version is the one we export to the Python module.",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "core.html#third-party-providers",
    "href": "core.html#third-party-providers",
    "title": "Claudette’s source",
    "section": "Third party providers",
    "text": "Third party providers\n\nAmazon Bedrock\nThese are Amazon’s current Claude models:\nWe don’t need any extra code to support Amazon Bedrock – we just have to set up the approach client:\n\nab = AnthropicBedrock(\n    aws_access_key=os.environ['AWS_ACCESS_KEY'],\n    aws_secret_key=os.environ['AWS_SECRET_KEY'],\n)\nclient = Client(models_aws[-1], ab)\n\n\nchat = Chat(cli=client)\n\n\nchat(\"I'm Jeremy\")\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_bdrk_01NbZjw5bVCMxoCu8b8hVuSu\ncontent: [{‘text’: “Hello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 10, ‘output_tokens’: 36}\n\n\n\n\n\n\nGoogle Vertex\n\nfrom anthropic import AnthropicVertex\nimport google.auth\n\n\nproject_id = google.auth.default()[1]\nregion = \"us-east5\"\ngv = AnthropicVertex(project_id=project_id, region=region)\nclient = Client(models_goog[-1], gv)\n\n\nchat = Chat(cli=client)\n\n\nchat(\"I'm Jeremy\")\n\nHello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?\n\n\nid: msg_vrtx_014RDYiPp7B2jkMJxzogWQaT\ncontent: [{‘text’: “Hello Jeremy! It’s nice to meet you. How can I assist you today? Is there anything specific you’d like to talk about or any questions you have?”, ‘type’: ‘text’}]\nmodel: claude-3-5-sonnet-20240620\nrole: assistant\nstop_reason: end_turn\nstop_sequence: None\ntype: message\nusage: {‘input_tokens’: 10, ‘output_tokens’: 36}",
    "crumbs": [
      "Claudette's source"
    ]
  },
  {
    "objectID": "CHANGELOG.html",
    "href": "CHANGELOG.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "CHANGELOG.html#section",
    "href": "CHANGELOG.html#section",
    "title": "",
    "section": "0.0.3",
    "text": "0.0.3\n\nNew Features\n\nAmazon Bedrock and Google Vertex support (#7)\n\n\n\nBug Fixes\n\nUpdate model paths for non-beta tool use (#2), thanks to @sarahpannn"
  },
  {
    "objectID": "CHANGELOG.html#section-1",
    "href": "CHANGELOG.html#section-1",
    "title": "",
    "section": "0.0.1",
    "text": "0.0.1\n\nInitial release"
  }
]